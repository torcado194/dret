<!DOCTYPE html>
<!--

.   .                                                   .o8          
.  o8                                                  "888          
.o888oo  .o8888o.  oooo d8b  .oooooo.   .oooo.    .ooooo888   .o8888o. 
. 888   d88'  `88b `888""8P d88'  `"Y8 `P  .88b  d88'  `888  d88'  `88b
. 888   888    888  888     888         .oP8888  888    888  888    888
. 888 . 888.  .888  888     888    .oo d8'  888  888.  .888  888.  .888
. "888"  "888888"  d888b    `Y8bood8P' `Y888""8o `Y8888888P"  "888888"

-->
<html lang="en">

    <head>
        <meta charset="utf-8">
        <title>ðŸ‡©ðŸ‡·ðŸ‡ªðŸ‡¹</title>
        <script src="/code/jquery.min.js"></script>
        <script src='/code/jquery-ui.min.js'></script>
        <script src='/code/perlin.js'></script>
        <link rel="stylesheet" type="text/css" href="/reset.css">
        <!--        <link rel="stylesheet" href="/style.css">-->
        <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto+Slab:400,700|Roboto:300,400,500&effect=outline" rel="stylesheet">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <link rel="shortcut icon" href="/favicon.ico"/>
    </head>
    <body>
        <div id="gameArea">
            <div id="dashboard">
                <div class="item" item="wood">
                    <div class="bg"></div>
                    <div class="icon"></div>
                    <div class="count">1.6k</div>
                </div>
                <div class="item" item="foliage">
                    <div class="bg"></div>
                    <div class="icon"></div>
                    <div class="count">81k</div>
                </div>
                <div class="item" item="stone">
                    <div class="bg"></div>
                    <div class="icon"></div>
                    <div class="count">73m</div>
                </div>
                <div class="item" item="grass">
                    <div class="bg"></div>
                    <div class="icon"></div>
                    <div class="count">446</div>
                </div>
                <div class="item" item="straw">
                    <div class="bg"></div>
                    <div class="icon"></div>
                    <div class="count">9,250</div>
                </div>
                <div class="item" item="apple">
                    <div class="bg"></div>
                    <div class="icon"></div>
                    <div class="count">0.1</div>
                </div>
            </div>
            <canvas id="canvas"></canvas>
        </div>
    </body>
    <style>
        @keyframes wobble{
            0%{
                transform: scale(0.8, 1.2);
            }
            50%{
                transform: scale(1.08, 0.92);
            }
            100%{
                transform: scale(1, 1);
            }
        }
        
        html{
            height: 100%;
        }
        body{
            height: 100%;
            overflow: hidden;
        }
        #gameArea{
            width: 100%;
            height: 100%;
            display: flex;
        }
        #dashboard{
            width: 512px;
            height: 100%;
            padding: 0 8px;
            background-color: firebrick;
            flex-grow: 0;
            background-image: url(image/dashMiddle.png);
            background-repeat: repeat-y;
            border-image: url(image/dashBorder.png);
            border-width: 8px;
            border-style: solid;
            border-image-width: 8px;
            border-image-slice: 8;
            box-sizing: border-box;
            border-left-width: 0px;
            border-right-width: 0;
            flex: 0 0 512px;
            display: flex;
        }
        #canvas{
            height: 100%;
            background-color: aqua;
            flex-grow: 1;
        }
        
        .item{
            width: 64px;
            height: 64px;
            position: relative;
            margin: 8px;
            user-select: none;
            cursor: pointer;
        }
        .item .bg{
            width: 100%;
            height: 100%;
            position: absolute;
            background-image: url(image/ui.png);
            background-position: 0px 0px;
        }
        .item .icon{
            width: 64px;
            height: 64px;
            position: absolute;
            background-image: url(image/items.png);
            background-position: 0px 0px;
            animation-play-state: running;
        }
        .item .count{
            width: 100%;
            height: 16px;
            position: absolute;
            text-align: right;
            bottom: 0;
            color: #FFF;
            font-family: 'Roboto', monospace;
            font-weight: 700;
            text-shadow: 0 1px 1px #000, 0 -1px 1px #000, 1px 0 1px #000, -1px 0 1px #000, 1px 1px 2px #000, 1px -1px 2px #000, -1px -1px 2px #000, -1px 1px 2px #000;
        }
        
        .item[item="wood"] .icon{
            background-position: 0px 0px;
        }
        .item[item="foliage"] .icon{
            background-position: -64px 0px;
        }
        .item[item="stone"] .icon{
            background-position: -128px 0px;
        }
        .item[item="grass"] .icon{
            background-position: -192px 0px;
        }
        .item[item="straw"] .icon{
            background-position: -256px 0px;
        }
        .item[item="apple"] .icon{
            background-position: -320px 0px;
        }
        
        .wobble{
            animation: wobble 0.25s;
        }
    </style>
    <script>
        
        //Global vars
        var canvas,
            c,
            macroCanvas,
            mc,
            chunkCanvas,
            cc,
            cview,
            tempMacroCanvas,
            tmc,
            tempChunkCanvas,
            tcc;
        
        var scale = 6,
            resolution = 1,
            chunkSize = 16,
            chunkBaseWidth = 96,
            chunkBaseHeight = 96,
            chunkWidth = chunkBaseWidth * scale,
            chunkHeight = chunkBaseHeight * scale,
            chunkC = chunkSize / resolution,
            chunkR = chunkSize / resolution,
            tileBaseWidth = chunkBaseWidth / chunkC,
            tileBaseHeight = chunkBaseHeight / chunkR,
            tileWidth = tileBaseWidth * scale,
            tileHeight = tileBaseHeight * scale,
            w = 0,
            h = 0,
            canvasX = 0,
            canvasY = 0,
            edgeMargin = 0,
            camX = 0,
            camY = 0,
            camXCenter = 0,
            camYCenter = 0,
            mcOffsetX = 0,
            mcOffsetY = 0,
            ccOffsetX = 0,
            ccOffsetY = 0,
            pressed = [],
            seed1 = 0,
            seed2 = 0,
            seed3 = 0,
            seed4 = 0,
            chunks = [],
            mouseX = 0,
            mouseY = 0,
            mouseRelX = 0,
            mouseRelY = 0,
            mouseTileX = 0,
            mouseTileY = 0,
            landmasses = [];
        
        var updateTime = new Date;
        
        //test
        var zoom = true;
        
        //Object Definitions
        function Chunk(x,y,color,dir){this.x = x; this.y = y; this.color = color; this.dir = dir; this.map = createMap(this)};
        function Tile(chunk,x,y,relX,relY,height,biome,bgBiome,color,bgColor,dir){this.chunk = chunk; this.x = x; this.y = y; this.relX = relX; this.relY = relY; this.height = height; this.biome = biome; this.bgBiome = bgBiome; this.color = color; this.bgColor = bgColor; this.dir = dir};
        function Landmass(x = 0, y = 0, map = [], outline = []){this.x = x; this.y = y; this.map = map; this.outline = outline}; //x,y,map,outline
        
        //Behavioral Functions
        function updateVars(){
            chunkWidth = chunkBaseWidth * scale;
            chunkHeight = chunkBaseHeight * scale;
            /*chunkC = chunkSize / resolution;
            chunkR = chunkSize / resolution;
            tileBaseWidth = chunkBaseWidth / chunkC;
            tileBaseHeight = chunkBaseHeight / chunkR;*/
            tileWidth = tileBaseWidth * scale;
            tileHeight = tileBaseHeight * scale;
        }
        
        function updateMouse(){
            mouseRelX = mouseX + camX;
            mouseRelY = mouseY + camY;
            mouseTileX = Math.floor((mouseRelX + ccOffsetX) / tileWidth);
            mouseTileY = Math.floor((mouseRelY + ccOffsetY) / tileHeight);
        }
        
        /*function toggleZoom(){
            zoom = !zoom;
            if(zoom){
                scale = 6;
                resolution = 1;
            } else {
                scale = 1;
                resolution = 2;
            }
            updateMouse();
            drawMap(cview);
        }*/
        
        function chunkZoom(chunk, zoomIn){
            if(zoomIn !== undefined){
                if(zoomIn == zoom){
                    return;
                }
            }
            zoom = !zoom;
            if(zoom){
                scale = 6;
                resolution = 1;
                updateVars();
                camX = ccOffsetX % w;
                camY = ccOffsetY % h;
                cview = cc;
            } else {
                scale = 1;
                resolution = 2;
                updateVars();
                camX = (ccOffsetX % w) - w;
                camY = (ccOffsetY % h) - h;
                cview = mc;
            }
            ccOffsetX = (chunk.x * chunkWidth + (chunkWidth / 2) - w / 2); 
            ccOffsetY = (chunk.y * chunkHeight + (chunkHeight / 2) - h / 2);
            console.log(chunk.x + " : " + camX + " : " + ccOffsetX);
            drawMap(cview, "full", chunk);
            updateMouse();
        }
        
        function generateChunk(x,y){
            var chunk = getChunkAt(x,y) || new Chunk(x, y, "#6dd853", 0);
            chunks.push(chunk);
            return chunk;
        }
        
        function generateChunkImages(chunk){
            fillTris(chunk);
            
            var vars = {};
            //macro
            vars.scale = 1;
            vars.resolution = 2;
            vars.chunkWidth = chunkBaseWidth * vars.scale;
            vars.chunkHeight = chunkBaseHeight * vars.scale;
            vars.tileWidth = tileBaseWidth * vars.scale;
            vars.tileHeight = tileBaseHeight * vars.scale;
            
            
            chunk.macroRender = document.createElement('canvas');
            chunk.macroRender.width = vars.chunkWidth;
            chunk.macroRender.height = vars.chunkHeight;
            chunk.mr = chunk.macroRender.getContext('2d');
                
                
            var c = chunk.mr;
            
            
            for(var i = 0; i < chunk.map.length; i+=vars.resolution){
                for(var j = 0; j < chunk.map[0].length; j+=vars.resolution){
                    var tile = chunk.map[i][j];
                    var tw = vars.tileWidth * vars.resolution,
                        th = vars.tileHeight * vars.resolution;
                    var tileX = tile.relX * (vars.tileWidth);
                    var tileY = tile.relY * (vars.tileHeight);
                    c.fillStyle = tile.bgColor;
                    c.fillRect(tileX, tileY, tw, th)
                    c.fillStyle = tile.color;
                    if(tile.dir == 0){
                        c.fillRect(tileX, tileY, tw, th)
                    } else if(tile.dir == 1) {
                        c.beginPath();
                        c.moveTo(tileX, tileY);
                        c.lineTo(tileX + tw, tileY + th);
                        c.lineTo(tileX, tileY + th);
                        c.fill();
                    } else if(tile.dir == 2) {
                        c.beginPath();
                        c.moveTo(tileX, tileY);
                        c.lineTo(tileX + tw, tileY);
                        c.lineTo(tileX, tileY + th);
                        c.fill();
                    } else if(tile.dir == 3) {
                        c.beginPath();
                        c.moveTo(tileX, tileY);
                        c.lineTo(tileX + tw, tileY);
                        c.lineTo(tileX + tw, tileY + th);
                        c.fill();
                    } else if(tile.dir == 4) {
                        c.beginPath();
                        c.moveTo(tileX + tw, tileY);
                        c.lineTo(tileX + tw, tileY + th);
                        c.lineTo(tileX, tileY + th);
                        c.fill();
                    } 
                }
            }
            
            //chunk.macroRender = c.canvas.toDataURL();
            
            //chunk
            
            vars.scale = 6;
            vars.resolution = 1;
            vars.chunkWidth = chunkBaseWidth * vars.scale;
            vars.chunkHeight = chunkBaseHeight * vars.scale;
            vars.tileWidth = tileBaseWidth * vars.scale;
            vars.tileHeight = tileBaseHeight * vars.scale;


            chunk.chunkRender = document.createElement('canvas');
            chunk.chunkRender.width = vars.chunkWidth;
            chunk.chunkRender.height = vars.chunkHeight;
            chunk.cr = chunk.chunkRender.getContext('2d');


            var c = chunk.cr;

            for(var i = 0; i < chunk.map.length; i+=vars.resolution){
                for(var j = 0; j < chunk.map[0].length; j+=vars.resolution){
                    var tile = chunk.map[i][j];
                    var tw = vars.tileWidth * vars.resolution,
                        th = vars.tileHeight * vars.resolution;
                    var tileX = tile.relX * (vars.tileWidth);
                    var tileY = tile.relY * (vars.tileHeight);
                    c.fillStyle = tile.bgColor;
                    c.fillRect(tileX, tileY, tw, th)
                    c.fillStyle = tile.color;
                    if(tile.dir == 0){
                        c.fillRect(tileX, tileY, tw, th)
                    } else if(tile.dir == 1) {
                        c.beginPath();
                        c.moveTo(tileX, tileY);
                        c.lineTo(tileX + tw, tileY + th);
                        c.lineTo(tileX, tileY + th);
                        c.fill();
                    } else if(tile.dir == 2) {
                        c.beginPath();
                        c.moveTo(tileX, tileY);
                        c.lineTo(tileX + tw, tileY);
                        c.lineTo(tileX, tileY + th);
                        c.fill();
                    } else if(tile.dir == 3) {
                        c.beginPath();
                        c.moveTo(tileX, tileY);
                        c.lineTo(tileX + tw, tileY);
                        c.lineTo(tileX + tw, tileY + th);
                        c.fill();
                    } else if(tile.dir == 4) {
                        c.beginPath();
                        c.moveTo(tileX + tw, tileY);
                        c.lineTo(tileX + tw, tileY + th);
                        c.lineTo(tileX, tileY + th);
                        c.fill();
                    } 
                }
            }

            //chunk.chunkRender = c.canvas.toDataURL();
        }
        
        function createMap(chunk){
            var map = [],
                w = chunkC,
                h = chunkR;

            for(var i = 0; i < w; i++){
                map[i] = [];
                for(var j = 0; j < h; j++){
                    var terrain = getTerrain((chunk.x * chunkC) + i, (chunk.y * chunkR) + j),
                        height = terrain.height,
                        biome = terrain.biome,
                        color = getTerrainColor(terrain),
                        bgBiome = biome,
                        bgColor = color;
                    map[i][j] = new Tile(chunk,i + (chunk.x * chunkC), j + (chunk.y * chunkR),i,j,height,biome,color,bgColor,Math.floor(Math.random() * 5))
                }   
            }
            return map;
        }
        
        function getTerrain(x,y){

            var a = 0;
            x *= 0.45;
            y *= 0.45;
            [x,y] = rotate(x,y,6.324);
            
            //Large base landmasses. iterations reduce frequency. beginning scale affects jaggedness
            var base;
            noise.seed(seed2);
            //[x,y] = rotate(x,y,26.5);
            var base1 = (noise.perlin2(x/12, y/12) + 1) / 2;
            noise.seed(seed4);
            var base2 = (noise.perlin2(x/5, y/5) + 1) / 2;
            a = (base1 + base2) / 2;
            for(var i = 0; i < 8; i++){
                noise.seed(seed1 + i ** 2);
                //[x,y] = rotate(x,y,i ** 7.823 + 12.14);
                base = (noise.perlin2(x/(60), y/(60)) + 1) / 2;
                a = (a * (base + 0.2));
            }
            
            //Buncha tweaking shit idk
            a *= 1.6;
            a **= 1.8;
            
            a **= 0.3;
            
            a /= base1 * 2;
            
            a = amp3(a, 0.9);
            
            a = a ** (0.8) * 0.8
            
            //More jagged edges
            a = a - (amp3(a, 0.36) * ((noise.perlin2(x/(4), y/(4)) + 1) / 2) * 0.2);
            //a = (a + ((noise.perlin2(x/(4), y/(4)) + 1) / 2)) / 2;
            
            //a = (a * ((noise.perlin2(x/5, y/5) + 1) / 2 + 0.2)) / 1;
            
            
            //Mountains. 
            noise.seed(seed3);
            //[x,y] = rotate(x,y,4.325);
            var mountains = (noise.perlin2(x/8, y/8) + 1) / 2;
            
            for(var i = 0; i < 5; i++){
                noise.seed(seed3 + i ** 4);
                //[x,y] = rotate(x,y,i ** 2.276 + 1.53);
                base = (noise.perlin2(x/(8), y/(8)) + 1) / 2;
                mountains = (mountains * (base + 0.2));
            }
            
            //Clip mountans within landmasses
            mountains *= a * 2.44;
            
            a += mountains;
            
            //Normalize
            a = ((-1) / (2 ** (2 * a)) + 1) * 1.1;
            
            
            
            //Biomes
            /////////////////////////////////////
            
            //Base. 
            noise.seed(seed2);
            //[x,y] = rotate(x,y,4.325);
            //var biomeBase = (noise.perlin2(x/1, y/1) + 1) / 2;
            
            x *= 0.5;
            y *= 0.5; 
            var maxAmp = 0,
                amp = 1,
                f = 1 / 140,
                biomeBase = 0;

            for(var i = 0; i < 6; i++){
                noise.seed(seed2 + i ** 3.3);
                //[x,y] = rotate(x,y,i ** 2.276 + 1.53);
                biomeBase += ((noise.simplex2(x*f, y*f) + 1) / 2) * amp;
                maxAmp += amp;
                amp *= 1;
                f *= 1.8;
            }
            
            var maxAmp2 = 0,
                amp2 = 1,
                f2 = 1 / 140,
                biomeBase2 = 0;

            for(var i = 0; i < 6; i++){
                noise.seed(seed4 + i ** 3.3);
                //[x,y] = rotate(x,y,i ** 2.276 + 1.53);
                biomeBase2 += ((noise.simplex2(x*f2, y*f2) + 1) / 2) * amp2;
                maxAmp2 += amp2;
                amp2 *= 1;
                f2 *= 1.8;
            }
            
            var biome1 = Math.round(((biomeBase / maxAmp) * 2 - 0.5) * 3.5);
            var biome2 = Math.round(((biomeBase2 / maxAmp2) * 2 - 0.5) * 3.5);
            //a = (((biomeBase / maxAmp) * 2 - 0.5) + ((biomeBase2 / maxAmp2) * 2 - 0.5)) / 2;
            //a = (biome1 + biome2) / 2;
            
            biome1 = Math.min(3,Math.max(1,biome1));
            biome2 = Math.min(3,Math.max(1,biome2));
            
            var biome = 0;
            
            if(biome1 == 1 && biome2 == 1) biome = 0; //puddle (lagoon)
            if(biome1 == 1 && biome2 == 2) biome = 1; //jungle
            if(biome1 == 1 && biome2 == 3) biome = 6; //tundra
            if(biome1 == 2 && biome2 == 1) biome = 3; //forest
            if(biome1 == 2 && biome2 == 2) biome = 4; //planes
            if(biome1 == 2 && biome2 == 3) biome = 5; //arctic
            if(biome1 == 3 && biome2 == 1) biome = 6; //tundra
            if(biome1 == 3 && biome2 == 2) biome = 7; //desert
            if(biome1 == 3 && biome2 == 3) biome = 8; //meteor
            
            if(biome == 0 && a < 0.53) biome = 2; //shore lake -> swamp
            if(!(biome == 0 || biome == 2 || biome == 7) && a <= 0.366) biome = 7; //shore land -> desert
            if(biome == 8 && a < 0.55) biome = 7; //shore meteor -> desert
            //if(biome == 8 && a > 0.71) biome = 2; //mountain meteor -> lava?
            if(biome == 0 && a > 0.66) biome = 1; //high lake -> jungle?
            if((biome == 6 || biome == 5) && a > 0.77) biome = 9; //high tundra/desert -> lava (basalt?)
            if(biome != 6 && biome != 7 && biome != 9 && a > 0.78) biome = 5; //mountain 
            
            
            
            /*var c = biomeBase;
            
            noise.seed(seed4 + 12);
            biomeBase = (noise.perlin2(x/10, y/10) + 1) / 2;
            for(var i = 0; i < 3; i++){
                noise.seed(seed4 + i ** 5);
                //[x,y] = rotate(x,y,i ** 2.276 + 1.53);
                base = (noise.perlin2(x/(8+i), y/(8+i)) + 1) / 2;
                biomeBase = (biomeBase * (base + 0.22));
            }
            
            noise.seed(seed1 + 51);
            var clamp = amp(Math.min(1,(noise.perlin2(x/25, y/25) + 1) / 2 + 0.23), 0.98);
            
            a = a + amp((c + biomeBase) * Math.min(1, clamp), 0.8) * 100;*/
            
            
            return {height:  Math.round(Math.min(1,Math.max(0,a)) * 10) / 10, biome: biome};
        }

        function amp(x,v){
            return Math.max(0,(-400) * Math.pow((x-v),4) + 1)
        }

        function amp2(x,v){
            return Math.max(0,(-200) * Math.pow((x-v),2) + 1)
        }
        
        function amp3(x,v){
            return Math.max(0,(-10) * Math.pow((x-v),6) + 1)
        }
        
        function rotate(x,y,a){
            var i = x - 90000,
                j = y - 90000;
            return [
                Math.cos(a) * (x - i) - Math.sin(a) * (y - j) + i,
                Math.sin(a) * (x - i) - Math.cos(a) * (y - j) + j
                   ]
        }
        
        
        function getTerrainColor(terrain){
            /*var colors = [
                [207, 0.72, 0.38],
                [171, 0.74, 0.38],
                [93, 0.50, 0.50],
                [73, 0.55, 0.55],
                [64, 0.64, 0.66],
                [40, 0.5, 0.58]
            ],
                positions = [
                    0,
                    0.25,
                    0.5,
                    0.8,
                    0.9,
                    1
                ];*/
            /*var colors = [ //planes
                [207, 0.72, 0.38],
                [131, 0.54, 0.42],
                [84, 0.50, 0.52],
                [54, 0.45, 0.66]
            ],*/
            /*var colors = [ //forest
                [207, 0.72, 0.38],
                [131, 0.41, 0.42],
                [99, 0.36, 0.54],
                [67, 0.54, 0.64]
            ],*/
            /*var colors = [ //jungle
                [207, 0.72, 0.38],
                [100, 0.47, 0.35],
                [84, 0.38, 0.46],
                [68, 0.46, 0.58]
            ],*/
            /*var colors = [ //tundra
                [207, 0.72, 0.38],
                [55, 0.24, 0.37],
                [47, 0.35, 0.50],
                [54, 0.50, 0.63]
            ],*/
            /*var colors = [ //tundra
                [207, 0.72, 0.38],
                [84, 0.28, 0.39],
                [58, 0.32, 0.49],
                [56, 0.50, 0.62]
            ],*/
            /*var colors = [ //tundra good
                [207, 0.72, 0.38],
                [84, 0.42, 0.42],
                [59, 0.48, 0.54],
                [64, 0.59, 0.68]
            ],*/
            /*var colors = [ //desert
                [207, 0.72, 0.38],
                [42, 0.41, 0.58],
                [53, 0.60, 0.72],
                [58, 0.87, 0.85]
            ],*/
            /*var colors = [ //arctic
                [207, 0.72, 0.38],
                [218, 0.32, 0.69],
                [218, 0.31, 0.88],
                [218, 0.87, 1.00]
            ],*/
            /*var colors = [ //lagoon
                [207, 0.72, 0.38],
                [215, 0.99, 0.60],
                [206, 0.99, 0.63],
                [193, 0.99, 0.66]
            ],*/
            /*var colors = [ //slough (swamp)
                [207, 0.72, 0.38],
                [222, 0.10, 0.38],
                [251, 0.09, 0.52],
                [267, 0.15, 0.63]
            ],*/
            /*var colors = [ //slough (swamp) (not sure which is better. maybe this one)
                [207, 0.72, 0.38],
                [180, 0.10, 0.37],
                [212, 0.05, 0.48],
                [284, 0.08, 0.63]
            ],*/
            /*var colors = [ //basalt (volcano)
                [207, 0.72, 0.38],
                [3, 0.75, 0.17],
                [3, 0.75, 0.17],
                [3, 0.79, 0.54]
            ],*/
            /*var colors = [ //meteor
                [207, 0.72, 0.38],
                [260, 0.20, 0.45],
                [296, 0.58, 0.76],
                [336, 0.75, 0.86]
            ],
                positions = [
                    0,
                    0.25,
                    0.75,
                    1
                ];*/
            /*var colors = [
                [0, 0, 0],
                [0, 0, 1]
            ],
                positions = [
                    0,
                    1
                ];*/
            
            var colors = [
                [ //lagoon
                    [207, 0.72, 0.38],
                    [199, 0.84, 0.57],
                    [215, 0.88, 0.52],
                    [206, 0.88, 0.56],
                    [193, 0.88, 0.58]
                ],
                [ //jungle
                    [207, 0.72, 0.38],
                    [199, 0.84, 0.57],
                    [100, 0.47, 0.35],
                    [ 84, 0.38, 0.46],
                    [ 68, 0.46, 0.58]
                ],
                /*[ //slough
                    [207, 0.72, 0.38],
                    [215, 0.43, 0.51],
                    [222, 0.10, 0.38],
                    [251, 0.09, 0.52],
                    [267, 0.15, 0.63]
                ],*/
                [ //slough
                    [207, 0.72, 0.38],
                    [215, 0.43, 0.51],
                    [159, 0.33, 0.33],
                    [154, 0.35, 0.37],
                    [150, 0.37, 0.39]
                ],
                [ //forest
                    [207, 0.72, 0.38],
                    [199, 0.84, 0.57],
                    [131, 0.41, 0.42],
                    [ 99, 0.36, 0.54],
                    [ 67, 0.54, 0.64]
                ],
                [ //planes
                    [207, 0.72, 0.38],
                    [199, 0.84, 0.57],
                    [131, 0.54, 0.42],
                    [ 84, 0.50, 0.52],
                    [ 54, 0.45, 0.66]
                ],
                [ //arctic
                    [207, 0.72, 0.38],
                    [199, 0.84, 0.57],
                    [218, 0.32, 0.69],
                    [218, 0.31, 0.88],
                    [218, 0.87, 1.00]
                ],
                [ //tundra
                    [207, 0.72, 0.38],
                    [199, 0.84, 0.57],
                    [ 84, 0.42, 0.42],
                    [ 59, 0.48, 0.54],
                    [ 64, 0.59, 0.68]
                ],
                [ //desert
                    [207, 0.72, 0.38],
                    [199, 0.84, 0.57],
                    [ 42, 0.41, 0.58],
                    [ 53, 0.60, 0.72],
                    [ 58, 0.87, 0.85]
                ],
                [ //meteor
                    [207, 0.72, 0.38],
                    [199, 0.84, 0.57],
                    [260, 0.20, 0.45],
                    [296, 0.58, 0.76],
                    [336, 0.75, 0.86]
                ],
                [ //basalt
                    [207, 0.72, 0.38],
                    [199, 0.84, 0.57],
                    [351, 1.00, 0.27],
                    [351, 1.00, 0.27],
                    [359, 0.83, 0.46]
                ]
            ],
                positions = [
                    0,
                    0.25,
                    0.2501,
                    0.75,
                    1
                ];
            
            var height = terrain.height,
                biome = terrain.biome;
            
            var color = linearGradient(colors[biome], positions, height);
            
            /*if(height > 0.1){
                switch (biome) {
                    default:
                    case 0: //lake
                        color = [215, 1.00, 0.60]
                        break;
                    case 1: //jungle
                        color = [71, 0.81, 0.34]
                        break;
                    case 2: //swamp
                        color = [309, 0.10, 0.56]
                        break;
                    case 3: //forest
                        color = [117, 0.70, 0.35]
                        break;
                    case 4: //planes
                        color = [106, 0.49, 0.54]
                        break;
                    case 5: //snow
                        color = [106, 0.0, 0.91]
                        break;
                    case 6: //tundra
                        color = [73, 0.62, 0.53]
                        break;
                    case 7: //desert
                        color = [52, 0.79, 0.71]
                        break;
                    case 8: //meteor
                        color = [322, 0.51, 0.70]
                        break;
                    case 9: //lava
                        color = [5, 0.77, 0.63]
                        break;
                    case 10: //mountain
                        color = [34, 0.79, 0.61]
                        break;
                }
            }*/
            
            return "hsl(" + (color[0]) + ", " + (color[1] * 100) + "%, " + (color[2] * 100) + "%)";
        }
        
        function linearGradient(colors, positions, val){
            var count = colors.length,
                props = colors[0].length,
                result = [];
            for(var i = 0; i < props; i++){
                var sectionColors = [],
                    sectionPositions = [];
                for(var j = 0; j < count; j++){
                    sectionColors.push(colors[j][i])
                    sectionPositions.push(positions[j]);
                }
                result.push(lerp(sectionColors,sectionPositions,val));
            }
            return result;
        }
        
        function lerp(colors, positions, val){
            var count = colors.length,
                norm;
            
            val = Math.max(0, Math.min(1, val));

            for(var i = 0; i < count - 1; i++){
                var a = positions[i],
                    b = positions[i+1];
                if(val >= a && val <= b){
                    norm = (val - a) / (b - a);
                    return norm * colors[i+1] + (1 - norm) * colors[i];
                }
            }
        }
        
        function getTileAt(x,y, safe = true){
            var tileX = ((x % chunkC) + chunkC) % chunkC,
                tileY = ((y % chunkR) + chunkR) % chunkR,
                chunkX = Math.floor(x / chunkC),
                chunkY = Math.floor(y / chunkR);
            for(var a = 0; a < chunks.length; a++){
                var chunk = chunks[a]
                if(chunk.x == chunkX && chunk.y == chunkY){
                    return chunk.map[tileX][tileY];
                }
            }
            return safe ? chunks[0].map[0][0] : false;
        }
        
        function getChunkAt(x,y){
            for(var a = 0; a < chunks.length; a++){
                var chunk = chunks[a]
                if(chunk.x == x && chunk.y == y){
                    return chunk;
                }
            }
            return false;
        }
        
        function getChunkAtTile(x,y){
            var chunkX = Math.floor(x / chunkC),
                chunkY = Math.floor(y / chunkR);
            for(var a = 0; a < chunks.length; a++){
                var chunk = chunks[a]
                if(chunk.x == chunkX && chunk.y == chunkY){
                    return chunk;
                }
            }
            return false;
        }
        
        function floodFill(x,y,landmass){
            //debugger;
            var tolerance = 0.2,
                tiles = [],
                visited = [],
                outline = [];
            //tiles.push(getTileAt(x,y));
            
            function flood(x1,y1){
                var tile = getTileAt(x1,y1),
                    segment = [],
                    right = false,
                    down = false,
                    left = false,
                    up = false;
                //if(visited.includes(tile)) return false;
                //visited.push(tile);
                if(tiles.includes(tile)) return false;
                if(tile.height < tolerance) return true;
                tiles.push(tile);
                tile.landmass = landmass;
                var tileX = tile.x,
                    tileY = tile.y;
                if(flood(x1+1,y1)){
                    segment.push([tileX+1,tileY]);
                    segment.push([tileX+1,tileY+1]);
                    right = true;
                }
                if(flood(x1,y1+1)){
                    segment.push([tileX+1,tileY+1]);
                    segment.push([tileX,tileY+1]);
                    down = true;
                }
                if(flood(x1-1,y1)){
                    segment.push([tileX,tileY+1]);
                    segment.push([tileX,tileY]);
                    left = true;
                }
                if(flood(x1,y1-1)){
                    if(right){
                        segment.splice(0,0,[tileX,tileY],[tileX+1,tileY])
                    } else {
                        segment.push([tileX,tileY]);
                        segment.push([tileX+1,tileY]);
                    }
                    up = true;
                }
                if(segment.length > 0){
                    outline.push(segment);
                }
                if(segment.length == 4 && ((right == true && down == true) || (down == true && left == true) || (left == true && up == true) || (up == true && right == true))){
                    segment.splice(1,2);
                }
                return false;
            }
            flood(x,y);
            
            return [tiles, arrayToPath(outline)]
        }
        
        function arrayToPath(array){
            var path = new Path2D();
            
            for(var i = 0; i < array.length; i++){
                for(var j = 0; j < array[i].length; j+=2){
                    path.moveTo(array[i][j][0],array[i][j][1]);
                    path.lineTo(array[i][j+1][0],array[i][j+1][1]);
                }
            }
            
            return path;
        }
        
        function populateLandmasses(){
            for(var a = 0; a < chunks.length; a++){
                var chunk = chunks[a];
                for(var i = 0; i < chunk.map.length; i++){
                    for(var j = 0; j < chunk.map[0].length; j++){
                        var tile = chunk.map[i][j];
                        if(!tile.landmass && tile.height >= 0.2){
                            var l = new Landmass();
                            [l.map, l.outline] = floodFill(tile.x,tile.y,l);
                            landmasses.push(l);
                        }
                    }
                }
            }
        }
        
        function fillTris(chunk){
            
            if(chunk){
                fill(chunk);
            } else {
                for(var a = 0; a < chunks.length; a++){
                    fill(chunks[a]);
                }
            }
            
            function fill(chunk){
                for(var i = 0; i < chunk.map.length; i++){
                    for(var j = 0; j < chunk.map[0].length; j++){
                        var tile = chunk.map[i][j];
                        var height = tile.height;
                        var biome = tile.biome;
                        var adj = [
                            getTileAt(tile.x, tile.y - 1, false) || getTerrain(tile.x, tile.y - 1),
                            getTileAt(tile.x + 1, tile.y, false) || getTerrain(tile.x + 1, tile.y),
                            getTileAt(tile.x, tile.y + 1, false) || getTerrain(tile.x, tile.y + 1),
                            getTileAt(tile.x - 1, tile.y, false) || getTerrain(tile.x - 1, tile.y)
                        ]
                        
                        adj.map(function(item){
                            if(!item.color){
                                item.color = getTerrainColor(item);
                            }
                            return item;
                        })
                        
                        var adjCount = adj.filter((item)=>(item.height >= height)).length;
                        tile.bgColor = (adj.filter((item)=>(item.height < height))[0] || tile).color;

                        tile.dir = 0;
                        if(adjCount >= 3){
                            //tile.dir = 0;
                        } else if(adjCount == 2){
                            if((adj[0].height >= height && adj[2].height >= height) || (adj[1].height >= height && adj[3].height >= height)){
                                //tile.dir = 0;
                            } else if((adj[0].height >= height && adj[1].height >= height)){
                                tile.dir = 3;
                            } else if((adj[1].height >= height && adj[2].height >= height)){
                                tile.dir = 4;
                            } else if((adj[2].height >= height && adj[3].height >= height)){
                                tile.dir = 1;
                            } else if((adj[3].height >= height && adj[0].height >= height)){
                                tile.dir = 2;
                            }
                        }
                        if(tile.dir == 0){
                            adjCount = adj.filter((item)=>(item.biome != biome)).length;
                            if(adjCount == 4){

                            } else if(adjCount == 3){
                                if(adj[0].biome >= biome){
                                    tile.dir = 2;
                                } else if(adj[1].biome >= biome){
                                    tile.dir = 3;
                                } else if(adj[2].biome >= biome){
                                    tile.dir = 4;
                                } else if(adj[3].biome >= biome){
                                    tile.dir = 1;
                                }
                            } else if(adjCount == 2){
                                if((adj[0].biome >= biome && adj[2].biome >= biome) || (adj[1].biome >= biome && adj[3].biome >= biome)){
                                    //tile.dir = 0;
                                } else if((adj[0].biome >= biome && adj[1].biome >= biome)){
                                    tile.dir = 3;
                                } else if((adj[1].biome >= biome && adj[2].biome >= biome)){
                                    tile.dir = 4;
                                } else if((adj[2].biome >= biome && adj[3].biome >= biome)){
                                    tile.dir = 1;
                                } else if((adj[3].biome >= biome && adj[0].biome >= biome)){
                                    tile.dir = 2;
                                }
                            } else {

                            }
                            if(tile.dir != 0){
                                tile.bgColor = (adj.filter((item)=>(item.biome != biome))[0] || tile).color;
                                tile.bgBiome = (adj.filter((item)=>(item.biome != biome))[0] || tile).biome;
                                /*if(tile.dir == 1){
                                        tile.bgColor = getTileAt(tile.x + 1, tile.y - 1).color;
                                    } else if(tile.dir == 2){
                                        tile.bgColor = getTileAt(tile.x + 1, tile.y + 1).color;
                                    } else if(tile.dir == 3){
                                        tile.bgColor = getTileAt(tile.x - 1, tile.y + 1).color;
                                    } else if(tile.dir == 4){
                                        tile.bgColor = getTileAt(tile.x - 1, tile.y - 1).color;
                                    }*/
                            }
                        }
                    }
                }
            }
        }
        
        function averageTile(tiles){
            
        }
        
        
        //Update
        function step(time){
            updateCamera();
            draw();
            window.requestAnimationFrame(step);
        }
        
        function updateCamera(){
            if(pressed.includes("ArrowLeft")){
                camX-=5;
            }
            if(pressed.includes("ArrowRight")){
                camX+=5;
            }
            if(pressed.includes("ArrowUp")){
                camY-=5;
            }
            if(pressed.includes("ArrowDown")){
                camY+=5;
            }
            camXCenter = camX + w / 2;
            camYCenter = camY + h / 2;
            
            if(camX >= w){
                camX = 0;
                ccOffsetX += w;
                let cx = Math.floor((ccOffsetX + (w) + (chunkWidth / 2)) / chunkWidth),
                    cy = Math.floor((ccOffsetY + (camYCenter)) / chunkHeight);
                drawMap(cview, "right",  generateChunk(cx, cy));
            }
            if(camX < 0){
                camX = w;
                ccOffsetX -= w;
                let cx = Math.floor((ccOffsetX + (w) - (chunkWidth / 2)) / chunkWidth),
                    cy = Math.floor((ccOffsetY + (camYCenter)) / chunkHeight);
                drawMap(cview, "left",  generateChunk(cx, cy));
            }
            if(camY >= h){
                camY = 0;
                ccOffsetY += h;
                let cx = Math.floor((ccOffsetX + (camXCenter)) / chunkWidth),
                    cy = Math.floor((ccOffsetY + (h) + (chunkHeight / 2)) / chunkHeight);
                drawMap(cview, "down", generateChunk(cx, cy));
            }
            if(camY < 0){
                camY = h;
                ccOffsetY -= h;
                let cx = Math.floor((ccOffsetX + (camXCenter)) / chunkWidth),
                    cy = Math.floor((ccOffsetY + (h) - (chunkHeight / 2)) / chunkHeight);
                drawMap(cview, "up",  generateChunk(cx, cy));
            }
        }
        
        
        function draw(){
            //var mainCanvas;
            //mainCanvas = zoom ? chunkCanvas : macroCanvas;
            c.setTransform(1, 0, 0, 1, -Math.floor(camX), -Math.floor(camY));
            c.drawImage(cview.canvas, 0, 0);
            
            c.strokeStyle = "hsl(328, 100%, 67%)";
            //c.strokeRect(Math.floor((mouseRelX)/(chunkWidth)) * chunkWidth, Math.floor((mouseRelY)/(chunkHeight)) * chunkHeight, chunkWidth, chunkHeight);
            //c.strokeRect(Math.floor((mouseRelX)/(tileWidth)) * tileWidth, Math.floor((mouseRelY)/(tileHeight)) * tileHeight, tileWidth, tileHeight);
            
            c.strokeRect(mouseTileX * tileWidth - ccOffsetX, mouseTileY * tileHeight - ccOffsetY, tileWidth, tileHeight);
            c.strokeRect(Math.floor(mouseTileX / chunkC) * chunkWidth - ccOffsetX, Math.floor(mouseTileY / chunkR) * chunkHeight - ccOffsetY, chunkWidth, chunkHeight);
            
            
            c.fillText(getTileAt(mouseTileX, mouseTileY).height, mouseRelX, mouseRelY);
            c.fillText(mouseTileX + ", " + mouseTileY, mouseRelX, mouseRelY - 20);
            
            
            c.save();
            c.scale(tileWidth, tileHeight);
            c.lineWidth = 0.5;
            c.strokeStyle = "hsl(48, 100%, 64%)";
            c.lineCap = "round";
            for(var i = 0; i < landmasses.length; i++){
                c.stroke(landmasses[i].outline);
            }
            c.restore();
        }
        
        function drawMap(c, area = "full", startChunk = false){
            
            var canvas = c.canvas;
            var a = 0,
                bounds = {},
                vars = {};
            
            bounds.top    = ((area == "down")  ? h : 0);
            bounds.right  = ((area == "left")  ? w : w * 2);
            bounds.bottom = ((area == "up")    ? h : h * 2);
            bounds.left   = ((area == "right") ? w : 0);
            bounds.width  = bounds.right - bounds.left;
            bounds.height = bounds.bottom - bounds.top;
            bounds.offsetX = ccOffsetX;
            bounds.offsetY = ccOffsetY;
            
            vars.scale = scale;
            vars.resolution = resolution;
            vars.chunkWidth = chunkWidth;
            vars.chunkHeight = chunkHeight;
            vars.tileWidth = tileWidth;
            vars.tileHeight = tileHeight;
            
            c.setTransform(1, 0, 0, 1, -bounds.offsetX, -bounds.offsetY);
            
            c.drawImage(canvas, bounds.left, bounds.top, bounds.width, bounds.height, (area == "left" ? w : 0) + bounds.offsetX, (area == "up" ? h : 0) + bounds.offsetY, bounds.width, bounds.height);
            //mc.fillRect(0, 0, 4 * scale, 4 * scale)

            //if(pressed.includes("ArrowLeft") || pressed.includes("ArrowRight") || pressed.includes("ArrowUp") || pressed.includes("ArrowDown"))

            
            //tileWidth *= resolution;
            //tileHeight *= resolution;
            
            //c.fillStyle = "#7FC6FF";
            //c.fillRect(camXCenter, camYCenter,canvas.width,canvas.height);
            
            var startX = 0,
                startY = 0;
            
                if(startChunk){
                    startX = startChunk.x;
                    startY = startChunk.y;
                } else {
                    startX = Math.floor((bounds.left + bounds.offsetX) / vars.chunkWidth);
                    startY = Math.floor((bounds.top + bounds.offsetY) / vars.chunkHeight);
                }
                
            
            search(c, a, startX, startY, bounds, vars);
            
            function search(c, a, startX, startY, bounds, vars){
                var list = [];
                
                var checkX = 0,
                    checkY = 0,
                    cx = 0,
                    cy = 0,
                    d = 0,
                    i = 0;
                //debugger;
                while(true){
                    checkY = Math.floor(((bounds.top + bounds.offsetY) / vars.chunkHeight) + Math.floor(i / Math.ceil(bounds.width / (vars.chunkWidth))));
                    if(checkY > Math.floor((bounds.bottom + bounds.offsetY) / vars.chunkHeight) + 1){
                        break;
                    }
                    checkX = Math.floor(((bounds.left + bounds.offsetX) / vars.chunkWidth) + (i % Math.ceil(bounds.width / (chunkWidth))));
                    d = Math.hypot(checkX - startX, checkY - startY);
                    list.push({x:checkX,y:checkY,d:d});
                    i++;
                }
                
                list.sort(function(a,b){
                    return a.d - b.d;
                });
                
                render(c, a, bounds, vars, list);
                
                function render(c, a, bounds, vars, list){
                    var chunk,
                        cx = list[a].x,
                        cy = list[a].y;
                    
                    if(!(chunk = getChunkAt(cx, cy))){
                        chunk = generateChunk(cx, cy);
                        //fillTris(chunk);
                    }

                    drawChunk(c, chunk, vars);

                    if(++a < list.length){
                        if((new Date) - updateTime < 15){
                            render(c, a, bounds, vars, list);
                        } else {
                            updateTime = new Date;
                            requestAnimationFrame(function(){
                                render(c, a, bounds, vars, list);
                            })
                        }
                    }
                }
                
            }
            
            
            function drawChunk(c, chunk, vars){
                
                if(!chunk.chunkRender){
                    generateChunkImages(chunk);
                }
                
                //var img = new Image;
                //img.src = vars.resolution == 2 ? chunk.macroRender : chunk.chunkRender;
                
                c.drawImage(vars.resolution == 2 ? chunk.macroRender : chunk.chunkRender, chunk.x * vars.chunkWidth, chunk.y * vars.chunkHeight);
                
                
                /*for(var i = 0; i < chunk.map.length; i+=vars.resolution){
                    for(var j = 0; j < chunk.map[0].length; j+=vars.resolution){
                        var tile = chunk.map[i][j];
                        var tw = vars.tileWidth * vars.resolution,
                            th = vars.tileHeight * vars.resolution;
                        var tileX = tile.x * (vars.tileWidth);
                        var tileY = tile.y * (vars.tileHeight);
                        //if(tileX > camXCenter && tileX < camX + canvas.width / 2 && tileY > camYCenter && tileY < camY + canvas.height / 2){
                        c.fillStyle = tile.bgColor;
                        c.fillRect(tileX, tileY, tw, th)
                        c.fillStyle = tile.color;
                        if(tile.dir == 0){
                            c.fillRect(tileX, tileY, tw, th)
                        } else if(tile.dir == 1) {
                            c.beginPath();
                            c.moveTo(tileX, tileY);
                            c.lineTo(tileX + tw, tileY + th);
                            c.lineTo(tileX, tileY + th);
                            c.fill();
                        } else if(tile.dir == 2) {
                            c.beginPath();
                            c.moveTo(tileX, tileY);
                            c.lineTo(tileX + tw, tileY);
                            c.lineTo(tileX, tileY + th);
                            c.fill();
                        } else if(tile.dir == 3) {
                            c.beginPath();
                            c.moveTo(tileX, tileY);
                            c.lineTo(tileX + tw, tileY);
                            c.lineTo(tileX + tw, tileY + th);
                            c.fill();
                        } else if(tile.dir == 4) {
                            c.beginPath();
                            c.moveTo(tileX + tw, tileY);
                            c.lineTo(tileX + tw, tileY + th);
                            c.lineTo(tileX, tileY + th);
                            c.fill();
                        } 
                        //}
                    }
                }*/
            }
            
        }
        
        //Initialization
        function init(){
            canvas = document.getElementById("canvas");
            c = canvas.getContext('2d');
            //canvas.width = window.innerWidth;
            //canvas.height = window.innerHeight;
            canvas.width = $("#canvas").width();
            canvas.height = $("#canvas").height();
            canvasX = $("#canvas").offset().left;
            canvasY = $("#canvas").offset().top;
            w = canvas.width;
            h = canvas.height;
            
            seed1 = Math.floor(Math.random() * 1200 + 300);
            seed2 = Math.floor(Math.random() * 1200 + 300);
            seed3 = Math.floor(Math.random() * 1200 + 300);
            seed4 = Math.floor(Math.random() * 1200 + 300);
            
            /*seed1 = 667;
            seed2 = 668;
            seed3 = 669;
            seed4 = 666;*/
            
            /*seed1 = 1163;
            seed2 = 1343;
            seed3 = 855;
            seed4 = 1334;*/
            
            /*seed1 = 1157;
            seed2 = 1251;
            seed3 = 403;
            seed4 = 341;*/
            
            /*seed1 = 1379;
            seed2 = 1390;
            seed3 = 676;
            seed4 = 1266;*/
            
            /*seed1 = 1039;
            seed2 = 411;
            seed3 = 1301;
            seed4 = 342;*/
            
            seed1 = 510;
            seed2 = 1375;
            seed3 = 751;
            seed4 = 1083;
            
            noise.seed(seed1);
            
            var a = 4;

            //Gen map
            for(var i = 0; i < a**2; i++){
                chunks.push(new Chunk(i % a - a / 2, Math.floor(i / a) - a / 2, "#6dd853", 0));
            }
            //fillTris();
            
            //Create macro canvas
            
            macroCanvas = document.createElement('canvas');
            macroCanvas.width = w * 2 + edgeMargin * 2;
            macroCanvas.height = h * 2 + edgeMargin * 2;
            mc = macroCanvas.getContext('2d');
            //drawMap(mc);
            
            //create chunk canvas
            
            chunkCanvas = document.createElement('canvas');
            chunkCanvas.width = w * 2 + edgeMargin * 2;
            chunkCanvas.height = h * 2 + edgeMargin * 2;
            cc = chunkCanvas.getContext('2d');
            cview = cc;
            
            //create temp canvases

            scale = 1;
            resolution = 2;
            updateVars();
            
            tempMacroCanvas = document.createElement('canvas');
            tempMacroCanvas.chunkWidth;
            tempMacroCanvas.chunkHeight;
            tmc = tempMacroCanvas.getContext('2d');
            
            scale = 6;
            resolution = 1;
            updateVars();

            tempChunkCanvas = document.createElement('canvas');
            tempChunkCanvas.chunkWidth;
            tempChunkCanvas.chunkHeight;
            tcc = tempChunkCanvas.getContext('2d');
            
            
            
            drawMap(cc);
            
            step();
        }
        
        init();
        
        
        //Event handlers
        document.addEventListener("DOMMouseScroll", mouseWheel, false);
        document.addEventListener("mousewheel", mouseWheel, false);
        document.addEventListener("mousemove", mouseMove, false);
        document.addEventListener("mousedown", mouseDown, false);
        document.addEventListener("keydown", keyDown, false);
        document.addEventListener("keyup", keyUp, false);
        
        function mouseMove(e) {
            mouseX = e.clientX - canvasX;
            mouseY = e.clientY - canvasY;
            mouseRelX = mouseX + camX;
            mouseRelY = mouseY + camY;
            mouseTileX = Math.floor((mouseRelX + ccOffsetX) / tileWidth);
            mouseTileY = Math.floor((mouseRelY + ccOffsetY) / tileHeight);
        }
        
        function mouseDown(e) {
            //floodFill(mouseTileX, mouseTileY)
            //chunkZoom(getChunkAtTile(mouseTileX, mouseTileY));
        }
        
        function mouseWheel(e) {
            //floodFill(mouseTileX, mouseTileY)
            chunkZoom(getChunkAtTile(mouseTileX, mouseTileY), e.deltaY < 0);
        }
        
        function keyDown(e) {
            if(!pressed.includes(e.key)){
                pressed.push(e.key);
            };
        }

        function keyUp(e) {
            if(pressed.includes(e.key)){
                pressed.splice(pressed.indexOf(e.key), 1);
            };
        }
        
        
        $('.item').click(function(){
            var target = $(".icon", this)
            target.removeClass('wobble');
            setTimeout(function(){
                target.addClass('wobble');
            },50)
        });
        
    </script>
</html>