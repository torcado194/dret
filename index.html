<!DOCTYPE html>
<!--

.   .                                                   .o8          
.  o8                                                  "888          
.o888oo  .o8888o.  oooo d8b  .oooooo.   .oooo.    .ooooo888   .o8888o. 
. 888   d88'  `88b `888""8P d88'  `"Y8 `P  .88b  d88'  `888  d88'  `88b
. 888   888    888  888     888         .oP8888  888    888  888    888
. 888 . 888.  .888  888     888    .oo d8'  888  888.  .888  888.  .888
. "888"  "888888"  d888b    `Y8bood8P' `Y888""8o `Y8888888P"  "888888"

-->
<html lang="en">

    <head>
        <meta charset="utf-8">
        <title>ðŸ‡©ðŸ‡·ðŸ‡ªðŸ‡¹</title>
        <script src="/code/jquery.min.js"></script>
        <script src='/code/jquery-ui.min.js'></script>
        <script src='/code/perlin.js'></script>
        <link rel="stylesheet" type="text/css" href="/reset.css">
        <!--        <link rel="stylesheet" href="/style.css">-->
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <link rel="shortcut icon" href="/favicon.ico"/>
    </head>
    <body>
        <canvas id="canvas"></canvas>
    </body>
    <script>
        
        //Global vars
        var canvas,
            c,
            mapCanvas,
            mc;
        
        var scale = 1,
            chunkBaseWidth = 100,
            chunkBaseHeight = 100,
            chunkWidth = chunkBaseWidth * scale,
            chunkHeight = chunkBaseHeight * scale,
            chunkC = 10,
            chunkR = 10,
            tileBaseWidth = chunkWidth / chunkC,
            tileBaseHeight = chunkHeight / chunkR,
            tileWidth = tileBaseWidth * scale,
            tileHeight = tileBaseHeight * scale,
            camX = 0,
            camY = 0,
            camXCenter = 0,
            camYCenter = 0,
            pressed = [],
            seed1 = 0,
            seed2 = 0,
            seed3 = 0,
            seed4 = 0,
            chunks = [],
            mouseX = 0,
            mouseY = 0,
            mouseRelX = 0,
            mouseRelY = 0,
            mouseTileX = 0,
            mouseTileY = 0,
            landmasses = [];
        
        var outline = new Path2D();
        
        //Object Definitions
        function Chunk(x,y,color,dir){this.x = x; this.y = y; this.color = color; this.dir = dir; this.map = createMap(this)};
        function Tile(chunk,x,y,height,color,dir){this.chunk = chunk; this.x = x; this.y = y; this.height = height; this.color = color; this.dir = dir};
        function Landmass(){}; //x,y,map,outline
        
        //Behavioral Functions
        function createMap(chunk){
            var map = [],
                w = 10,
                h = 10;

            for(var i = 0; i < w; i++){
                map[i] = [];
                for(var j = 0; j < h; j++){
                    var height = getHeight((chunk.x * chunkC) + i, (chunk.y * chunkR) + j),
                        color = getHeightColor(height);
                    map[i][j] = new Tile(chunk,i,j,height,color,Math.floor(Math.random() * 5))
                }   
            }
            return map;
        }
        
        /*function getHeight(x,y){

            var a = 0;

            //Base landmass shapes
            noise.seed(seed1);
            var base = (noise.perlin2(x/28, y/28) + 1) / 2;

            a = amp(base, 0.22) - 0.16;

            noise.seed(seed4);
            var a2 = Math.max(0, noise.perlin2(x/50, y/50) * 2 - 0.5);

            //a = 1 - (1 - a) * (1 - a2);


            //Gen mountains
            var mountains = (amp(base, 0.1) ** (1.5)) * 1.67;

            a = a + (mountains - a) * 0.2;

            //islands
            noise.seed(seed2);
            var c = (noise.perlin2(x/22, y/22) + 1) / 2;
            noise.seed(seed3);
            var b = (noise.perlin2(x/8, y/8) + 1) / 2;

            var islands = ((amp(b, 0.3) * amp(c, 0.7))) * 0.8;

            //islands applied with screen method
            a = 1 - (1 - a) * (1 - islands);


            //rivers
            noise.seed(seed4);
            var d = (noise.perlin2(x/15, y/15) + 1) / 2;

            var e = ((1 - a) * 3) - 0.2;

            var rivers = amp2(d, 0.46) * 0.9

            rivers = Math.min(1,Math.max(0,(rivers) * e));

            a -= a * rivers;

            return Math.min(1,Math.max(0,a));
        }*/
        
        function getHeight(x,y){

            var a = 0;

            x *= 1.3;
            y *= 1.3;
            [x,y] = rotate(x,y,6.324);
            
            //Large base landmasses. iterations reduce frequency. beginning scale affects jaggedness
            var base;
            noise.seed(seed2);
            //[x,y] = rotate(x,y,26.5);
            var base1 = (noise.perlin2(x/12, y/12) + 1) / 2;
            a = base1;
            for(var i = 0; i < 8; i++){
                noise.seed(seed1 + i ** 2);
                //[x,y] = rotate(x,y,i ** 7.823 + 12.14);
                base = (noise.perlin2(x/(60), y/(60)) + 1) / 2;
                a = (a * (base + 0.2));
            }
            
            //Buncha tweaking shit idk
            a *= 1.6;
            a **= 1.8;
            
            a **= 0.3;
            
            a /= base1 * 2;
            
            a = amp3(a, 0.9);
            
            a = a ** (0.8) * 0.8
            
            //More jagged edges
            a = a - (amp3(a, 0.36) * ((noise.perlin2(x/(4), y/(4)) + 1) / 2) * 0.2);
            //a = (a + ((noise.perlin2(x/(4), y/(4)) + 1) / 2)) / 2;
            
            //a = (a * ((noise.perlin2(x/5, y/5) + 1) / 2 + 0.2)) / 1;
            
            
            //Mountains. 
            noise.seed(seed3);
            //[x,y] = rotate(x,y,4.325);
            var mountains = (noise.perlin2(x/8, y/8) + 1) / 2;
            
            for(var i = 0; i < 5; i++){
                noise.seed(seed3 + i ** 4);
                //[x,y] = rotate(x,y,i ** 2.276 + 1.53);
                base = (noise.perlin2(x/(8), y/(8)) + 1) / 2;
                mountains = (mountains * (base + 0.2));
            }
            
            //Clip mountans within landmasses
            mountains *= a * 2.44;
            
            a += mountains;
            
            //Normalize
            a = ((-1) / (2 ** (2 * a)) + 1) * 1.1;
            
            return Math.min(1,Math.max(0,a));
        }

        function amp(x,v){
            return Math.max(0,(-400) * Math.pow((x-v),4) + 1)
        }

        function amp2(x,v){
            return Math.max(0,(-200) * Math.pow((x-v),2) + 1)
        }
        
        function amp3(x,v){
            return Math.max(0,(-10) * Math.pow((x-v),6) + 1)
        }
        
        function rotate(x,y,a){
            var i = x - 90000,
                j = y - 90000;
            return [
                Math.cos(a) * (x - i) - Math.sin(a) * (y - j) + i,
                Math.sin(a) * (x - i) - Math.cos(a) * (y - j) + j
                   ]
        }
        
        
        function getHeightColor(h){
            var colors = [
                [207, 0.72, 0.38],
                [171, 0.74, 0.38],
                [93, 0.50, 0.50],
                [73, 0.55, 0.55],
                [64, 0.64, 0.66],
                [40, 0.5, 0.58]
            ],
                positions = [
                    0,
                    0.25,
                    0.5,
                    0.8,
                    0.9,
                    1
                ];
            /*var colors = [
                [0, 0, 0],
                [0, 0, 1]
            ],
                positions = [
                    0,
                    1
                ];*/
            
            var color = linearGradient(colors, positions, h);
            
            return "hsl(" + (color[0]) + ", " + (color[1] * 100) + "%, " + (color[2] * 100) + "%)";
        }
        
        function linearGradient(colors, positions, val){
            var count = colors.length,
                props = colors[0].length,
                result = [];
            for(var i = 0; i < props; i++){
                var sectionColors = [],
                    sectionPositions = [];
                for(var j = 0; j < count; j++){
                    sectionColors.push(colors[j][i])
                    sectionPositions.push(positions[j]);
                }
                result.push(lerp(sectionColors,sectionPositions,val));
            }
            return result;
        }
        
        function lerp(colors, positions, val){
            var count = colors.length,
                norm;
            
            val = Math.max(0, Math.min(1, val));

            for(var i = 0; i < count - 1; i++){
                var a = positions[i],
                    b = positions[i+1];
                if(val >= a && val <= b){
                    norm = (val - a) / (b - a);
                    return norm * colors[i+1] + (1 - norm) * colors[i];
                }
            }
        }
        
        function getTileAt(x,y){
            var tileX = (x % chunkC),
                tileY = (y % chunkR),
                chunkX = Math.floor(x / chunkC),
                chunkY = Math.floor(y / chunkR);
            for(var a = 0; a < chunks.length; a++){
                var chunk = chunks[a]
                if(chunk.x == chunkX && chunk.y == chunkY){
                    return chunk.map[tileX][tileY];
                }
            }
            return chunks[0].map[0][0];
        }
        
        function floodFill(x,y,landmass){
            //debugger;
            var tolerance = 0.2,
                tiles = [],
                visited = [],
                outline = [];
            //tiles.push(getTileAt(x,y));
            
            function flood(x1,y1){
                var tile = getTileAt(x1,y1),
                    segment = [],
                    right = false,
                    down = false,
                    left = false,
                    up = false;
                //if(visited.includes(tile)) return false;
                //visited.push(tile);
                if(tiles.includes(tile)) return false;
                if(tile.height < tolerance) return true;
                tiles.push(tile);
                tile.landmass = landmass;
                var tileX = (tile.x + tile.chunk.x * chunkC),
                    tileY = (tile.y + tile.chunk.y * chunkR);
                if(flood(x1+1,y1)){
                    segment.push([tileX+1,tileY]);
                    segment.push([tileX+1,tileY+1]);
                    right = true;
                }
                if(flood(x1,y1+1)){
                    segment.push([tileX+1,tileY+1]);
                    segment.push([tileX,tileY+1]);
                    down = true;
                }
                if(flood(x1-1,y1)){
                    segment.push([tileX,tileY+1]);
                    segment.push([tileX,tileY]);
                    left = true;
                }
                if(flood(x1,y1-1)){
                    if(right){
                        segment.splice(0,0,[tileX,tileY],[tileX+1,tileY])
                    } else {
                        segment.push([tileX,tileY]);
                        segment.push([tileX+1,tileY]);
                    }
                    up = true;
                }
                if(segment.length > 0){
                    outline.push(segment);
                }
                if(segment.length == 4 && ((right == true && down == true) || (down == true && left == true) || (left == true && up == true) || (up == true && right == true))){
                    segment.splice(1,2);
                }
                return false;
            }
            flood(x,y);
            
            return [tiles, arrayToPath(outline)]
        }
        
        function arrayToPath(array){
            /*var newArray = [],
                path = new Path2D();
            
            newArray[0] = array[0];
            
            for(var i = 0; i < array.length; i++){
                if(array[i][0] == newArray[i][0] && array[i][1] == newArray[i][1]){
                    
                }
            }*/
            
            var path = new Path2D();
            
            
            for(var i = 0; i < array.length; i++){
                for(var j = 0; j < array[i].length; j+=2){
                    path.moveTo(array[i][j][0],array[i][j][1]);
                    path.lineTo(array[i][j+1][0],array[i][j+1][1]);
                }
            }
            
            return path;
        }
        
        function populateLandmasses(){
            for(var a = 0; a < chunks.length; a++){
                var chunk = chunks[a];
                for(var i = 0; i < chunk.map.length; i++){
                    for(var j = 0; j < chunk.map[0].length; j++){
                        var tile = chunk.map[i][j];
                        if(tile.landmass == undefined){
                            var l = new Landmass()
                            landmasses.push(l);
                            [l.map, l.outline] = floodFill(tile.x,tile.y,l);
                        }
                    }
                }
            }
        }
        
        
        
        //Update
        function step(time){
            updateCamera();
            draw();
            window.requestAnimationFrame(step);
        }
        
        function updateCamera(){
            if(pressed.includes("ArrowLeft")){
                camX-=5;
            }
            if(pressed.includes("ArrowRight")){
                camX+=5;
            }
            if(pressed.includes("ArrowUp")){
                camY-=5;
            }
            if(pressed.includes("ArrowDown")){
                camY+=5;
            }
            camXCenter = camX + canvas.width / 2;
            camYCenter = camY + canvas.height / 2;
        }
        
        function draw(){
            c.setTransform(1, 0, 0, 1, -Math.floor(camX), -Math.floor(camY));
            c.drawImage(mapCanvas, 0, 0);
            
            c.strokeStyle = "hsl(328, 100%, 67%)";
            c.strokeRect(Math.floor((mouseRelX)/(chunkWidth)) * chunkWidth, Math.floor((mouseRelY)/(chunkHeight)) * chunkHeight, chunkWidth, chunkHeight);
            c.strokeRect(Math.floor((mouseRelX)/(tileWidth)) * tileWidth, Math.floor((mouseRelY)/(tileHeight)) * tileHeight, tileWidth, tileHeight);
            
            
            c.fillText(getTileAt(mouseTileX, mouseTileY).height, mouseRelX, mouseRelY);
            c.fillText(mouseTileX + ", " + mouseTileY, mouseRelX, mouseRelY - 20);
            
            
            c.save();
            c.scale(tileWidth, tileHeight);
            c.lineWidth = 0.5;
            c.strokeStyle = "hsl(48, 100%, 64%)";
            c.lineCap = "round";
            c.stroke(outline);
            c.restore();
            
            
            /*if((mouseRelXCenter) >= tileX && (mouseRelXCenter) <= tileX + tileWidth && (mouseRelYCenter) >= tileY && (mouseRelYCenter) <= tileY + tileHeight){
                mc.strokeStyle = "hsl(328, 100%, 67%)";
                mc.strokeRect(tileX, tileY, tileWidth, tileHeight);
            }*/
            
            /*for(var a = 0; a < chunks.length; a++){
                var chunk = chunks[a];
                var chunkX = chunk.x * chunkWidth;
                var chunkY = chunk.y * chunkHeight;
                for(var i = 0; i < chunk.map.length; i++){
                    for(var j = 0; j < chunk.map[0].length; j++){
                        var tile = chunk.map[i][j];
                        if(mouseRelX / tileWidth >= chunk.x * chunkC + tile.x && mouseRelX / tileWidth < chunk.x * chunkC + tile.x + 1 && mouseRelY / tileHeight >= chunk.y * chunkR + tile.y && mouseRelY / tileHeight < chunk.y * chunkR + tile.y + 1){
                            c.fillText(tile.height, mouseRelX, mouseRelY);
                        }
                    }
                }
            }*/
        }
        
        function drawMap(){
            //mc.setTransform(1, 0, 0, 1, Math.floor((canvas.width / 2) - camX), Math.floor((canvas.height / 2) - camY));

            //mc.fillRect(0, 0, 4 * scale, 4 * scale)

            //if(pressed.includes("ArrowLeft") || pressed.includes("ArrowRight") || pressed.includes("ArrowUp") || pressed.includes("ArrowDown"))

            mc.fillStyle = "#7FC6FF";
            mc.fillRect(camXCenter, camYCenter,canvas.width,canvas.height);

            for(var a = 0; a < chunks.length; a++){
                var chunk = chunks[a];
                var chunkX = chunk.x * chunkWidth;
                var chunkY = chunk.y * chunkHeight;
                //if(!(chunkX > camXCenter && chunkX < camX + canvas.width / 2 && chunkY > camYCenter && chunkY < camY + canvas.height / 2))
                //    continue;
                //mc.fillStyle = chunk.color;
                //mc.fillRect(chunkX, chunkY, chunkWidth, chunkHeight)
                for(var i = 0; i < chunk.map.length; i++){
                    for(var j = 0; j < chunk.map[0].length; j++){
                        var tile = chunk.map[i][j];
                        var tileX = chunkX + tile.x * tileWidth;
                        var tileY = chunkY + tile.y * tileHeight;
                        //if(tileX > camXCenter && tileX < camX + canvas.width / 2 && tileY > camYCenter && tileY < camY + canvas.height / 2){
                        mc.fillStyle = tile.color;
                        mc.fillRect(tileX, tileY, tileWidth, tileHeight)
                        /*if(tile.dir == 0){
                        } else if(tile.dir == 1) {
                            mc.beginPath();
                            mc.moveTo(tileX + tileWidth, tileY);
                            mc.lineTo(tileX + tileWidth, tileY + tileHeight);
                            mc.lineTo(tileX, tileY + tileHeight);
                            mc.fill();
                        } else if(tile.dir == 2) {
                            mc.beginPath();
                            mc.moveTo(tileX, tileY);
                            mc.lineTo(tileX + tileWidth, tileY + tileHeight);
                            mc.lineTo(tileX, tileY + tileHeight);
                            mc.fill();
                        } else if(tile.dir == 3) {
                            mc.beginPath();
                            mc.moveTo(tileX, tileY);
                            mc.lineTo(tileX + tileWidth, tileY);
                            mc.lineTo(tileX, tileY + tileHeight);
                            mc.fill();
                        } else if(tile.dir == 4) {
                            mc.beginPath();
                            mc.moveTo(tileX, tileY);
                            mc.lineTo(tileX + tileWidth, tileY);
                            mc.lineTo(tileX + tileWidth, tileY + tileHeight);
                            mc.fill();
                        } */
                        //}
                    }
                }
            }
        }
        
        //Initialization
        function init(){
            canvas = document.getElementById("canvas");
            c = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            seed1 = Math.floor(Math.random() * 1200 + 300);
            seed2 = Math.floor(Math.random() * 1200 + 300);
            seed3 = Math.floor(Math.random() * 1200 + 300);
            seed4 = Math.floor(Math.random() * 1200 + 300);
            
            /*seed1 = 667;
            seed2 = 668;
            seed3 = 669;
            seed4 = 666;*/
            
            
            noise.seed(seed1);
            
            var a = 20;

            for(var i = 0; i < a**2; i++){
                chunks.push(new Chunk(i % a, Math.floor(i / a), "#6dd853", 0));
            }
            
            mapCanvas = document.createElement('canvas');
            mapCanvas.width = a*chunkWidth;
            mapCanvas.height = a*chunkHeight;
            mc = mapCanvas.getContext('2d');
            drawMap();
            
            step();
        }
        
        init();
        
        
        //Event handlers
        document.addEventListener("mousemove", mouseMove, false);
        document.addEventListener("mousedown", mouseDown, false);
        document.addEventListener("keydown", keyDown, false);
        document.addEventListener("keyup", keyUp, false);
        
        function mouseMove(e) {
            mouseX = e.clientX;
            mouseY = e.clientY;
            mouseRelX = mouseX + camX;
            mouseRelY = mouseY + camY;
            mouseTileX = Math.floor(mouseRelX / tileWidth);
            mouseTileY = Math.floor(mouseRelY / tileHeight);
        }
        
        function mouseDown(e) {
            floodFill(mouseTileX, mouseTileY)
        }
        
        function keyDown(e) {
            if(!pressed.includes(e.key)){
                pressed.push(e.key);
            };
        }

        function keyUp(e) {
            if(pressed.includes(e.key)){
                pressed.splice(pressed.indexOf(e.key), 1);
            };
        }
        
    </script>
    <style>
        body {
            overflow: hidden;
        }
    </style>
</html>