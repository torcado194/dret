<!DOCTYPE html>
<!--

.   .                                                   .o8          
.  o8                                                  "888          
.o888oo  .o8888o.  oooo d8b  .oooooo.   .oooo.    .ooooo888   .o8888o. 
. 888   d88'  `88b `888""8P d88'  `"Y8 `P  .88b  d88'  `888  d88'  `88b
. 888   888    888  888     888         .oP8888  888    888  888    888
. 888 . 888.  .888  888     888    .oo d8'  888  888.  .888  888.  .888
. "888"  "888888"  d888b    `Y8bood8P' `Y888""8o `Y8888888P"  "888888"

-->
<html lang="en">

    <head>
        <meta charset="utf-8">
        <title>ðŸ‡©ðŸ‡·ðŸ‡ªðŸ‡¹</title>
        <script src="/code/jquery.min.js"></script>
        <script src='/code/jquery-ui.min.js'></script>
        <script src='/code/perlin.js'></script>
        <link rel="stylesheet" type="text/css" href="/reset.css">
        <!--        <link rel="stylesheet" href="/style.css">-->
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <link rel="shortcut icon" href="/favicon.ico"/>
    </head>
    <body>
        <canvas id="canvas"></canvas>
    </body>
    <script>
        var canvas,
            c;
        
        var scale = 1,
            chunkWidth = 100,
            chunkHeight = 100,
            chunkC = 10,
            chunkR = 10,
            tileWidth = chunkWidth / chunkC,
            tileHeight = chunkHeight / chunkR,
            camX = 400,
            camY = 400,
            pressed = [],
            seed1 = 0,
            seed2 = 0,
            seed3 = 0,
            seed4 = 0,
            chunks = [];
        
        
        function Tile(chunk,x,y,color,dir){this.chunk = chunk; this.x = x; this.y = y; this.color = color; this.dir = dir};

        function noiseColor(x,y){
//            var a = 158,
//                b = 240;
            var a = 207,
                b = 93;
            var colors = [
                [207, 1, 0.75],
                [93, 1, 0.75],
                [93, 1, 0.75],
                [40, 0.95, 0.8]
            ],
                positions = [
                    0,
                    0.5,
                    0.75,
                    1
                ],
                val = getNoiseTile(x, y)
            
            //debugger;
            var color = linearGradient(colors, positions, val);
            //debugger;
            
            return "hsl(" + (color[0]) + ", " + (color[1] * 100) + "%, " + (color[2] * 100) + "%)";
            //return "hsl(0,0%," + ((a + getNoiseTile(x, y) * (b - a))) + "%)";
        }
        
        function linearGradient(colors, positions, val){
            var count = colors.length,
                props = colors[0].length,
                result = [];
            for(var i = 0; i < props; i++){
                var sectionColors = [],
                    sectionPositions = [];
                for(var j = 0; j < count; j++){
                    sectionColors.push(colors[j][i])
                    sectionPositions.push(positions[j]);
                }
                result.push(lerp(sectionColors,sectionPositions,val));
            }
            return result;
        }
        
        function lerp(colors, positions, val){
            var count = colors.length,
                norm;
            
            val = Math.max(0, Math.min(1, val));

            for(var i = 0; i < count - 1; i++){
                var a = positions[i],
                    b = positions[i+1];
                if(val >= a && val <= b){
                    norm = (val - a) / (b - a);
                    return norm * colors[i+1] + (1 - norm) * colors[i];
                }
            }
        }
        
        function getNoiseTile(x,y){
            
            
            /*noise.seed(seed1);
            var large = noise.simplex2(x / 50, y / 50) * 0.92;
            noise.seed(seed2);
            var small = noise.simplex2(x / 17, y / 17);
            noise.seed(seed3);
            var small2 = noise.simplex2(x / 24, y / 24);
            
            //var a = small + (((Math.abs(small) ** Math.abs(large)) - small) * 0.5);
            //console.log(small + " : " + ((small ** large) - small))
            var a = large + ((Math.abs(small) ** (3 - small2)) * 0.75);
            
            return Math.max(0.3, Math.min(1, (a + 1) / 2));*/
            
            
//            return ((noise.perlin3(x/8, y/8, Math.sin(x**y)/20) + 1) / 2);
            //return ((noise.simplex2(x/8, y/8) + 1.5) / 3);
            //return ((noise.perlin2(x/14, y/14) + 1) / 2);
            
            var a = 0;
            
            //Base landmass shapes
            noise.seed(seed1);
            var base = (noise.perlin3(x/28, y/28, 1) + 1) / 2;
            
            a = amp(base, 0.22) - 0.16;
            
            noise.seed(seed4);
            var a2 = Math.max(0, noise.perlin3(x/50, y/50, 1) * 2 - 0.5);
            
            a = 1 - (1 - a) * (1 - a2);
            
            
            //Gen mountains
            var mountains = (amp(base, 0.1) ** (1.5)) * 1.67;
            
            a = a + (mountains - a) * 0.2;
            
            //islands
            noise.seed(seed2);
            var c = (noise.perlin3(x/22, y/22, 1) + 1) / 2;
            noise.seed(seed3);
            var b = (noise.perlin3(x/8, y/8, 1) + 1) / 2;
            
            var islands = ((amp(b, 0.3) * amp(c, 0.7))) * 0.8;
            //a *= 0.75;
            //a = (a + (((amp(b, 0.3) * amp(c, 0.7))) - (a)) * 0.0);
            
            //islands applied with screen method
            a = 1 - (1 - a) * (1 - islands);
            
            
            //rivers
            noise.seed(seed4);
            var d = (noise.perlin3(x/15, y/15, 1) + 1) / 2;
            
            //noise.seed(seed2);
            //a = (((noise.perlin3(x/20, y/20, 1) + 1) / 2) + 0.20);
            var e = ((1 - a) * 3) - 0.2;
            
            var rivers = amp2(d, 0.46) * 0.9
            
            rivers = Math.min(1,Math.max(0,(rivers) * e));
            
            a -= a * rivers;
            //a = rivers;
            
            //a = a2;
            
            //a * 0.78;
            
            //a = (1.07 / (1 + 50 * (1000 ** (0 - a))) - 0.02);
            //a = (1.07 / (1 + 10000 * (Math.E ** (0 - 12 * a))) ** (1 / 3) - 0.05);
            
            
            //a = a + ((a-a**3)) * 0.2
            
            //if(a > 1) debugger;
            
            //noise.seed(667);
            //a = c;
            
            
            //debugger;
            
            return Math.min(1,Math.max(0,a));
        }
        
        function amp(x,v){
            return Math.max(0,(-400) * Math.pow((x-v),4) + 1)
        }
        
        function amp2(x,v){
            return Math.max(0,(-200) * Math.pow((x-v),2) + 1)
        }

        function createMap(chunk){
            var map = [],
                w = 10,
                h = 10;

            for(var i = 0; i < w; i++){
                map[i] = [];
                for(var j = 0; j < h; j++){
                    //debugger;
                    map[i][j] = new Tile(chunk,i,j,noiseColor((chunk.x * chunkC) + i, (chunk.y * chunkR) + j),Math.random() * 5)
                }   
            }
            return map;
        }

        function Chunk(x,y,color,dir){this.x = x; this.y = y; this.color = color; this.dir = dir; this.map = createMap(this)};

        function step(time){
            window.requestAnimationFrame(step);
            
            if(pressed.includes("ArrowLeft")){
                camX--;
            }
            if(pressed.includes("ArrowRight")){
                camX++;
            }
            if(pressed.includes("ArrowUp")){
                camY--;
            }
            if(pressed.includes("ArrowDown")){
                camY++;
            }
            
            c.setTransform(1, 0, 0, 1, (canvas.width / 2) - camX, (canvas.height / 2) - camY);
            
            for(var a = 0; a < chunks.length; a++){
                var chunk = chunks[a];
                var chunkX = chunk.x * chunkWidth * scale;
                var chunkY = chunk.y * chunkHeight * scale;
                c.fillStyle = chunk.color;
                c.fillRect(chunkX, chunkY, chunkWidth * scale, chunkHeight * scale)
                for(var i = 0; i < chunk.map.length; i++){
                    for(var j = 0; j < chunk.map.length; j++){
                        var tile = chunk.map[i][j];
                        var tileX = chunkX + tile.x * tileWidth * scale;
                        var tileY = chunkY + tile.y * tileHeight * scale;
                        c.fillStyle = tile.color;
                        c.fillRect(tileX, tileY, tileWidth * scale, tileHeight * scale)
                    }
                }
            }
        }
        
        function init(){
            canvas = document.getElementById("canvas");
            c = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            seed1 = Math.random();
            seed2 = Math.random();
            seed3 = Math.random();
            seed4 = Math.random();
            
            /*seed1 = 667;
            seed2 = 668;
            seed3 = 669;
            seed4 = 666;*/
            
            
            noise.seed(seed1);
            
            for(var i = 0; i < 64; i++){
                chunks.push(new Chunk(i % 8, Math.floor(i / 8), "#6dd853", 0));
            }
            
            step();
        }
        
        init();
        
        document.addEventListener("keydown", keyDownHandler, false);
        document.addEventListener("keyup", keyUpHandler, false);
        
        function keyDownHandler(e) {
            if(!pressed.includes(e.key)){
                pressed.push(e.key);
            };
        }

        function keyUpHandler(e) {
            if(pressed.includes(e.key)){
                pressed.splice(pressed.indexOf(e.key), 1);
            };
        }
        
    </script>
    <style>
        body {
            overflow: hidden;
        }
    </style>
</html>